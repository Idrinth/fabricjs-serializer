var idrinth=idrinth||{};idrinth.FabricJsSerializer=(()=>{const n=["left","top","type"],e=(n,e)=>"string"==typeof e&&{}.hasOwnProperty.call(n,e),t=class{constructor(n,e){if("function"!=typeof n)throw new Error("The factory has to be a function.");if(!Array.isArray(e))throw new Error("The dependencies have to be an array.");this.n=n,this.e=e}isDependant(n){return this.e.includes(n)}isSaveworthy(t,r){const i=n=>Array.isArray(n)&&!n.length;return!!n.includes(t)||!e(this.n,t)||!((n,e)=>n===e||i(n)&&i(e))(r,this.n[t])}};return class{constructor(n){this.t=n,this.r=(()=>({circle:new t(n=>new fabric.Circle(n),[]),ellipse:new t(n=>new fabric.Ellipse(n),[]),group:new t(n=>new fabric.Group(n.objects,n),[]),"i-text":new t(n=>new fabric.IText(n.text,n),[]),image:new t(n=>new fabric.Image.fromURL(n.src,n),[]),line:new t(n=>new fabric.Line(n.points,n),[]),linear:new t(n=>new fabric.Gradient(n),[]),object:new t(n=>new fabric.Object(n),[]),path:new t(n=>new fabric.Path(n.path,n),[]),point:new t(n=>new fabric.Point(n.x,n.y),[]),polygon:new t(n=>new fabric.Polygon(n.points,n),[]),polyline:new t(n=>new fabric.Polyline(n.points,n),[]),rect:new t(n=>new fabric.Rect(n),[]),radial:new t(n=>new fabric.Gradient(n),[]),text:new t(n=>new fabric.Text(n.text,n),[]),textbox:new t(n=>new fabric.Textbox(n.text,n),[]),triangle:new t(n=>new fabric.Triangle(n),[])}))()}register(n,e,...r){this.r[n]=new t(e,r||[])}fromJson(n){const t=JSON.parse(n),r=this.t.renderOnAddRemove;this.t.renderOnAddRemove=!1;for(const n of this.t._objects)this.t.remove(n);this.t._objects=[];const i={};for(let n=0;n<t.objects.length;n++){const e=t.objects[n].type+n;t.objects[n].i=e,i[e]=n}var o;o=this.r,t.objects.sort((n,t)=>{if(!e(o,n.type))throw new Error(`Can't find a definition for given type ${n.type}`);if(!e(o,t.type))throw new Error(`Can't find a definition for given type ${t.type}`);return o[n.type].isDependant(t.type)?1:o[t.type].isDependant(n.type)?-1:0});const s=new Array(t.objects.length).fill(null);for(const n of t.objects){const e=this.r[n.type].factory(n);this.t.add(e),s[i[n.i]]=e}this.t._objects=s,this.t.renderOnAddRemove=r,this.t.renderAll()}toJson(){const n=this.r;return JSON.stringify({version:fabric.version,objects:this.t._objects.map(t=>{const r=t.toObject();if(!r.type||!e(n,r.type))throw new Error(`Can't find a definition for given type ${r.type}`);const i={};for(const e of Object.keys(r))n[r.type].isSaveworthy(e,r[e])&&(i[e]=r[e]);return i})})}}})();